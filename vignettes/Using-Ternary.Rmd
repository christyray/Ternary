---
title: "Creating ternary plots with Ternary"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_document

vignette: >
  %\VignetteIndexEntry{Creating and manipulating ternary plots}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

I hope that this package proves simple to use.

Install the package with:

```{r Load package, eval=FALSE}
install.packages('Ternary')
```

Or if you want the latest development version of the package:

```{R Github package, eval=FALSE}
if (!require('devtools')) install.packages('devtools')
install_github('ms609/Ternary')
```

Once the package is installed, load it into the current R session with 
```{R Load}
library('Ternary')
```

There are two stages to creating a ternary plot: first, rendering the plot, styled
as you like it and pointing in any of the four compass directions; secondly, adding data.


## Create a blank plot
At its simplest, all you need to do is type
```{R Create blank plot}
TernaryPlot()
```

The following charts show which corners are which, under different orientations:

```{R Create simple plot, fig.width=7, fig.height=7}
par(mfrow=c(2, 2), mar=rep(0.5, 4))
for (dir in c('up', 'right', 'down', 'le')) {
  TernaryPlot(point=dir, atip='A', btip='B', ctip='C', alab='Aness', blab='Bness', clab='Cness')
  TernaryText(list(A=c(10, 01, 01), B=c(01, 10, 01), C=c(01, 01, 10)), col=cbPalette8[4], font=2)
}
```

## Plot two stylised plots side by side, and plot data
```{R Do plotting}
par(mfrow=c(1, 2), mar=rep(0.3, 4))
TernaryPlot(alab="Redder\u2192", blab="Greener \u2192", clab="Bluer \u2192",
            point='right', lab.cex=0.8, grid.minor.lines = 0,
            grid.lty='solid', col=rgb(0.9, 0.9, 0.9), grid.col='white', 
            axis.col=rgb(0.6, 0.6, 0.6), ticks.col=rgb(0.6, 0.6, 0.6),
            padding=0.08)
data_points <- list(
  R = c(255, 0, 0), 
  O = c(240, 180, 52),
  Y = c(210, 222, 102),
  G = c(111, 222, 16),
  B = c(25, 160, 243),
  I = c(92, 12, 243),
  V = c(225, 24, 208)
)
AddToTernary(points, data_points, bg=vapply(data_points, function (x) rgb(x[1], x[2], x[3], 128, maxColorValue=255), character(1)), pch=21, cex=2.8)
AddToTernary(text, data_points, names(data_points), cex=0.8, font=2)
legend('bottomright', 
       pch=21, pt.cex=1.8,
       pt.bg=c(rgb(255, 0, 0,   128, NULL, 255), 
             rgb(240, 180,  52, 128, NULL, 255),
             rgb(210, 222, 102, 128, NULL, 255),
             rgb(111, 222,  16, 128, NULL, 255)),
       legend=c('Red', 'Orange', 'Yellow', 'Green'), 
       cex=0.8, bty='n')

###
# Next plot:
###
TernaryPlot('Steam', 'Ice', 'Water', 
            grid.lines=5, grid.lty='dotted',
            grid.minor.lines = 1, grid.minor.lty='dotted',
            point='West')
HorizontalGrid()
middle_triangle <- matrix(c(
  30, 40, 30,
  30, 30, 40,
  55, 20, 25
), ncol=3, byrow=TRUE)
TernaryPolygon(middle_triangle, col='#aaddfa', border='grey')
TernaryLines(list(c(0, 100, 0), middle_triangle[1, ]), col='grey')
TernaryLines(list(c(0, 0, 100), middle_triangle[2, ]), col='grey')
TernaryLines(list(c(100, 0, 0), middle_triangle[3, ]), col='grey')
```


It is also possible to use cartesian coordinates to plot onto the graph.

By default, the plotting area is a 1x1 square.

```{r Cartesian}
TernaryPlot(point='right')
cat("X range in this orientation:", TernaryXRange())
cat("Y range in this orientation:", TernaryYRange())
arrows(x0=0.5, y0=0.4, x1=sqrt(3)/2, y1=0.4, length=0.1, col=cbPalette8[2])
text(x=mean(c(0.5, sqrt(3)/2)), y=0.4, "Increasing X", pos=3, col=cbPalette8[2])
text(x=0.5, y=0, "(0.5, 0)", col=cbPalette8[3])
text(x=0.8, y=-0.5, "(0.8, -0.5)", col=cbPalette8[3])
```

## Contours

A plot can be coloured and contoured according to the output of a function.
This function may be a mathematical expression, or relate to the density
of points across the ternary plot.

```{r contours}
FunctionToContour <- function (abc) {
  abc[1] - abc[3] + (4 * abc[1] * abc[2]) + (27 * abc[1] * abc[2] * abc[3])
}

TernaryPlot()
# Two functions required: One, with regular X & Y, using NA, to generate Zs for graphics::contour
# Two, to calculate and colour each triangle (doing ups then downs).

#' Value of a function at regularly spaced points
#'
#' @template directionParam
#' @return A matrix whose rows correspond to:
#' 
#' @author Martin R. Smith
TernaryPointValues <- function(Func, resolution = 30L, direction = getOption('ternDirection')) {
  if (direction == 1) {
    xRange <- c(-0.5, 0.5)
    dX <- 1
    yRange <- c(0, sqrt(0.75))
    dY <- sqrt(0.75)
    offset <- dX / resolution / 2L
    triangleHeight <- dY / resolution
    trianglesInRow <- 2L * rev(seq_len(resolution)) - 1L
    
    triX <- seq(from=xRange[1] + offset, to=xRange[2] - offset, by=offset)
    upY <- seq(from=yRange[1] + triangleHeight / 3,
               to=yRange[2] - (2 * triangleHeight / 3), length.out = resolution)
    x <- unlist(lapply(seq_len(resolution), function (yStep) {
      upX <- triX[seq(from=yStep, to=(2L * resolution) - yStep, by = 2L)]
      downX <- if(yStep == resolution) integer(0) else 
        triX[seq(from=yStep + 1, to = (2L * resolution) - yStep - 1, by = 2L)]
      c(rbind(upX, c(downX, NA)))[-((resolution - yStep + 1) * 2L)]
    }))
    y <- rep(upY[seq_len(resolution)], trianglesInRow)
    triDown <- (1 + unlist(lapply(trianglesInRow, seq_len))) %% 2L
    y <- y + (triDown * triangleHeight / 3)
  }
  xy <- rbind(x = x, y = y)
  # Return:
  rbind(xy, z = apply(xy, 2, function (xy) {Func(XYToTernary(xy))}), down = triDown)
}

values <- TernaryPointValues(FunctionToContour)
scale <- viridisLite::inferno(256)
z <- values['z', ]
zNorm <- z - min(z)
zNorm <- zNorm / max(zNorm)
zCol <- viridisLite::inferno(256)[as.integer(zNorm * 255) + 1L]
points(values['x', ], values['y', ], col=zCol)


#trimage <- function(f){
#    x = y = seq( 1, 0, l=181 )
#    z <- outer(X=x, Y=y, FUN=f)
#    t1 = length(x)
#    im = aux = numeric(0)
#    for( i in seq( 1, t1, by = 2 ) ){
#            idx = seq( i*t1, t1**2, by = t1 ) - (i-1)
#            im = c(im, aux, idx, aux )
#            aux = c(aux, NA)
#            }
#    return( matrix(z[im], nr=t1) )
#}
#
#########################################################
# Example:
#f = function(x1, x2){
#    x3 = 1 - x1 - x2
#    z = x1 + 0*x2 -x3 + 4*x1*x2 + 27*x1*x2*x3
#    return( z )
#    }
#

#
#z = trimage( f )
#par( xaxt='n', yaxt='n', bty='n', pty='s')
#image( z, col=rainbow(256))
#
#TernaryPointValues()
#contour( z, add=T )

```

```{r density-contours}
```


## Magnification

Perhaps the action on a plot is constrained to a small region of ternary space.
It's possible to "zoom in" -- i.e. magnify and crop the ternary plot to the region
of interest.

To do this you can specify the _x_ and _y_ limits of the region of interest. 

`TernaryCoords` might be useful in establishing the cartesian coordinates of a
particular point in ternary space.  
Ensure that _dx_ = _dy_ if you want an isometric plot.

```{r find-corners}
my_corners <- list(c(22, 66, 12), c(22, 72, 6), c(15, 80, 5), c(12, 76, 12))
lapply(my_corners, TernaryCoords, direction=1)
```

The `padding` parameter is added as a margin to each side of the region specified
using `xlim` and `ylim`:

```{r close-up}
TernaryPlot(xlim=c(0.28, 0.38), ylim=c(0.1, 0.2), padding=0.04)

# Annotate grid lines at user-specified points:
TernaryText(list(c(8, 72, 20), c(8, 82, 10)), c(20, 10), srt=-60, cex=0.9, col='darkgrey')
TernaryText(list(c(10, 69, 21), c(20, 64, 16)), c(10, 20), srt=0, cex=0.9, col='darkgrey')

# Plot desired polygon
TernaryPolygon(my_corners, col='#2cbe4e')

# Show xlim, ylim and padding, using cartesian coordinates
lines(c(0.28, 0.28, 0.38, 0.38, 0.28), c(0.1, 0.2, 0.2, 0.1, 0.1))
text(0.28, 0.15, "xlim[1]", pos=2, srt=90)
text(0.38, 0.15, "xlim[2]", pos=4, srt=90)
text(0.33, 0.1, "ylim[1]", pos=1)
text(0.33, 0.2, "ylim[2]", pos=3)
text(0.38, 0.1, '<padding>', pos=4, cex=0.75)
text(0.38, 0.1, '<padding> ', pos=2, cex=0.75, srt=90)
```

## Bugs and feature requests

I hope that the package comes in useful.  If there's anything it can't do that you wish
it could, please let me know by opening a [Github issue](https://github.com/ms609/Ternary/issues/new?title=I%20have%20a%20suggestion!).

 # # #
